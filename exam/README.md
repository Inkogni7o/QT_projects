## Вопросы для экзамена

### 1. Основы ООП, класс, объект
Класс - это абстрактный тип данных, который сочетает в себе два функционала:
- Структура, в которой можно хранить различные типы данных.
- ООП
```cpp
class Example {};
```
Создается класс с помощью команды, совпадающей по названию с классом, тн конструктор и удаляется из памяти аналогичной функцией с препиской в начале символа ~, тн деструктором 
У класса есть свойства и методы
- Свойства - все что может хранить информацию
- Методы - это функции, в функционале которых можно использовать свойства, объявляются в `.h`(заголовочных) файлах класса, описываются в `.cpp` файлах
```cpp 
// player.h

class Player {
    // свойство
    int level;
    // метод
    int level_up(int count);
};

// player.cpp
int level_up(int count) {
    level += count;
    return level;
}
```
>По сути своей класс - общее описание правил, по которому создаются конкретные экземпляры объектов класса. Довольно удобно, когда классических типов данных недостаточно для реализации программы. 

### 2. Принцип абстракции класса

**Абстракция** (от лат. abstractio — выделение, отвлечение или отделение) — 
теоретический прием исследования, позволяющий отвлечься от некоторых несущественных 
в определенном отношении свойств изучаемых явлений и выделить свойства существенные и определяющие.

---

Все языки программирования предоставляют их пользователю определённые абстракции. Так, языки семейства ассемблер являются в своём роде абстракцией соответствующих микропроцессоров, поскольку позволяют отвлечься от деталей их реализации и общаться с ними через определённый набор более высокоуровневых инструкций. Императивные языки программирования, последовавшие за ассемблером, например Basic, Fortran, C, являются более высоким уровнем абстракции над ассемблерными языками – они дают возможность использовать более привычные человеку синтаксические конструкции за счёт приближения синтаксиса к естественным языкам.
>В этом и состоит абстракция: фокусировка разработчика на конкретных свойствах объекта зависит от тех задач, которые призван решать объект. Следствием такого подхода является то, что, если в императивных языках разработчику необходимо думать в терминах компьютерной логики, в объектно-ориентированных языках разработчик думает в терминах проблемной области, в которой он разрабатывает приложения.

### 3. Принцип инкапсуляции класса
**Инкапсуляция**- сокрытие внутренних данных компонента и деталей его реализации от других компонентов приложения и предоставление набора методов для взаимодействия с ним (API).

---

Можем задавать модификаторы доступа для класса, всего их 3
- `public` - дает общий доступ к содержимому, которое в нем указано. К свойствам и методам можно обратиться из любой части программы (выставлен по умолчанию)
- `private` - запрещает обращаться к свойствам вне класса. Как правило, переменные, массивы, а также прототипы функций создают с этим модификатором доступа. Изменять переменные и прочее можно только из методов класса
- `protected` - аналогично предыдущему, дополнительный доступ имеют наследники класса

Соответственно, чтобы работать с закрытыми данными, используется API или так называемые сеттеры и геттеры
```cpp
// player.h
class Player {
    private: 
        int hp = 100;
        std::string name;
    public:
        int getHp(); // геттер
        void setName(std::string newName); // сеттер
}

// player.cpp
int getHp() {
    return hp;
}
void setName(std::string newName) {
    name = newName;
}
```

### 4. Принцип наследования класса

**Наследование** представляет один из ключевых аспектов объектно-ориентированного программирования, который позволяет наследовать функциональность одного класса или базового класса в другом - производном классе.
При наследовании все методы и свойства переходят к классу наследнику от его родителя.

При наследовании констуркторы не наследуются. Если базовый класс содержит только конструктор с параметрами, то и производный класс должен вызывать в своем конструкторе один из конструкторов базового класса.

Перед названием базового класса также можно указать модификатор доступа. `Public` позволяет использовать в производном классе все открытые члены базового класса. Если не использовать модификатор доступа, то класс `Son` ничего не будет знать о свойствах класса `Dad`.
Класс `Son` в данном случае называется производным классом, а класс `Dad` - базовым.

```cpp
class Dad {
    public:
        Dad(int age, float hp, std::string name) {
            // some work
        }
}
class Son : public Dad {
    public: 
        Son(int age1, float hp1, std::string name1, std::string date1) : Dad(age1, hp1, name1) {
            // some new work
        }
}
```
Когда нибудь может получиться так, что нужно будет запретить наследование. Для этого существует спецификатор `final`.
```cpp
class FinalFinalShit final {
    // some work 
}
```

### 5. Принцип полиморфизма
При рассмотрении полиморфизма необходимо помнить, что этот принцип неразрывно связан с другим принципом
    ООП – наследованием, которое помогает реализовать полиморфизм.
Возьмем для примера абстрактный класс «Автомобиль», который наследуют два конкретных класса – «Спортивный автомобиль» и «Грузовой автомобиль».
И спортивные, и грузовые автомобили будут обладать общими характеристиками и будут иметь возможность выполнять общие для всех автомобилей действия, которые указаны в абстрактном классе-родителе, но конкретная реализация этих действий может быть разной.
Например, общее для всех автомобилей действие «завестись» у спортивного автомобиля может быть реализовано путем нажатия кнопки, а у грузового - с помощью ключа. Один результат – разные решения. В этом и состоит полиморфизм.

> Более строго, **полиморфизм** - один из принципов ООП, позволяющий вызовом переопределённого метода через переменную класса-родителя получить поведение, которое будет соответствовать реальному классу-потомку, на который ссылается эта переменная.

### 6. Типы данных в С++. Пользовательские типы
Базовые типы данных:
- bool 
```cpp
bool isAlive {true};
bool isDead {false};
```
- целочисленные типы (`short`, `int`, `long` и тд)
- числа с плавающей точкой (`float`, `double`, `long double`)
- символьные типы (char и его клоны на разное количество памяти)

Пользовательские типы:
- классы и структуры
- объединения (аля кортежи из python, только хранят данные в одной области памяти)
```cpp
union MyUnion {
    int intValue;
    float floatValue;
}
```
- перечисления (enums)
```cpp
enum Colors {
    RED, BLUE, GREEN
} 
```
- шаблоны классов и функций 

### 7. Указатели в С++, адресная арифметика, ссылки

```cpp
// работа с указателями 
int value = 10;
int* ptr = &value; 
int x = *ptr;   // x = 10 
*ptr = 20       // value = 20

// адресная арифметика
int lst[3] = {30, 40, 50};
int* ptr1 = lst;
ptr++;          // *ptr -> 40
ptr--;          // *ptr -> 30
ptr = ptr + 2   // *ptr -> 50

// работа с ссылками
void increment(int& num) {
    num++;
}

void print(const int& name) { // константная ссылка, name не может быть изменен внутри функции
    // some work 
}

void main {
    int value = 10;
    increment(value);  // value = 11
}
```

### 8. Перечислимый тип enum

```cpp
enum Colors {
    RED,
    BLUE, 
    GREEN
};

enum class HttpStatus {
    OK = 200,
    NOT_FOUND = 404,
    INTERNAL_SERVER_ERROR = 500
};
```
Преимущества использования `enum`
- Улучшение читаемости кода: Именованные константы делают код более понятным
- Предотвращение ошибок: Использование enum помогает избежать ошибок, связанных с "магическими числами"
- Типобезопасность: `enum` class обеспечивает типобезопасность, предотвращая неявное преобразование к целочисленным типам

### 9. Пространство имен namespace
Пространство имен (namespace) в C++ используется для организации кода и предотвращения конфликтов имен. Оно позволяет группировать связанные сущности (классы, функции, переменные и т.д.) в логические блоки, что улучшает читаемость и поддержку кода.

1) Пространства имен помогают структурировать код, группируя связанные сущности.
```cpp
namespace Math {
    const double PI = 3.14159;
    double square(double x) {
        return x * x;
    }
}

void main() {
    double result = Math::square(5);                // Использование функции из пространства имен Math
    std::cout << "Result: " << result << std::endl; // Выведет 25
}
```
2) Пространства имен предотвращают конфликты имен, когда разные части кода используют одинаковые имена
```cpp
namespace ProjectA {
    void display() {
        std::cout << "Display from ProjectA" << std::endl;
    }
}

namespace ProjectB {
    void display() {
        std::cout << "Display from ProjectB" << std::endl;
    }
}

int main() {
    ProjectA::display(); // Выведет "Display from ProjectA"
    ProjectB::display(); // Выведет "Display from ProjectB"
}
```
3) Ключевое слово `using` позволяет упростить доступ к сущностям в пространстве имен
```cpp
namespace Math {
    const double PI = 3.14159;

    double square(double x) {
        return x * x;
    }
}

int main() {
    using namespace Math;
    double result = square(5); // Теперь можно использовать square без указания пространства имен
    std::cout << "Result: " << result << std::endl; // Выведет 25
    return 0;
}
```

### 10. Синтаксис класса в С++. Поля данных, методы
Прикола не понял, 
[см.1 вопрос](#1-основы-ооп-класс-объект)