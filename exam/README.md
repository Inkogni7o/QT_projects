## Вопросы для экзамена

### 1. Основы ООП, класс, объект
Класс - это абстрактный тип данных, который сочетает в себе два функционала:
- Структура, в которой можно хранить различные типы данных.
- ООП
```cpp
class Example {};
```
Создается класс с помощью команды, совпадающей по названию с классом, тн конструктор и удаляется из памяти аналогичной функцией с препиской в начале символа ~, тн деструктором 
У класса есть свойства и методы
- Свойства - все что может хранить информацию
- Методы - это функции, в функционале которых можно использовать свойства, объявляются в `.h`(заголовочных) файлах класса, описываются в `.cpp` файлах
```cpp 
// player.h

class Player {
    // свойство
    int level;
    // метод
    int level_up(int count);
};

// player.cpp
int level_up(int count) {
    level += count;
    return level;
}
```
>По сути своей класс - общее описание правил, по которому создаются конкретные экземпляры объектов класса. Довольно удобно, когда классических типов данных недостаточно для реализации программы. 

### 2. Принцип абстракции класса

**Абстракция** (от лат. abstractio — выделение, отвлечение или отделение) — 
теоретический прием исследования, позволяющий отвлечься от некоторых несущественных 
в определенном отношении свойств изучаемых явлений и выделить свойства существенные и определяющие.

---

Все языки программирования предоставляют их пользователю определённые абстракции. Так, языки семейства ассемблер являются в своём роде абстракцией соответствующих микропроцессоров, поскольку позволяют отвлечься от деталей их реализации и общаться с ними через определённый набор более высокоуровневых инструкций. Императивные языки программирования, последовавшие за ассемблером, например Basic, Fortran, C, являются более высоким уровнем абстракции над ассемблерными языками – они дают возможность использовать более привычные человеку синтаксические конструкции за счёт приближения синтаксиса к естественным языкам.
>В этом и состоит абстракция: фокусировка разработчика на конкретных свойствах объекта зависит от тех задач, которые призван решать объект. Следствием такого подхода является то, что, если в императивных языках разработчику необходимо думать в терминах компьютерной логики, в объектно-ориентированных языках разработчик думает в терминах проблемной области, в которой он разрабатывает приложения.

### 3. Принцип инкапсуляции класса
**Инкапсуляция**- сокрытие внутренних данных компонента и деталей его реализации от других компонентов приложения и предоставление набора методов для взаимодействия с ним (API).

---

Можем задавать модификаторы доступа для класса, всего их 3
- `public` - дает общий доступ к содержимому, которое в нем указано. К свойствам и методам можно обратиться из любой части программы (выставлен по умолчанию)
- `private` - запрещает обращаться к свойствам вне класса. Как правило, переменные, массивы, а также прототипы функций создают с этим модификатором доступа. Изменять переменные и прочее можно только из методов класса
- `protected` - аналогично предыдущему, дополнительный доступ имеют наследники класса

Соответственно, чтобы работать с закрытыми данными, используется API или так называемые сеттеры и геттеры
```cpp
// player.h
class Player {
    private: 
        int hp = 100;
        std::string name;
    public:
        int getHp(); // геттер
        void setName(std::string newName); // сеттер
}

// player.cpp
int getHp() {
    return hp;
}
void setName(std::string newName) {
    name = newName;
}
```

### 4. Принцип наследования класса

**Наследование** представляет один из ключевых аспектов объектно-ориентированного программирования, который позволяет наследовать функциональность одного класса или базового класса в другом - производном классе.
При наследовании все методы и свойства переходят к классу наследнику от его родителя.

При наследовании констуркторы не наследуются. Если базовый класс содержит только конструктор с параметрами, то и производный класс должен вызывать в своем конструкторе один из конструкторов базового класса.

Перед названием базового класса также можно указать модификатор доступа. `Public` позволяет использовать в производном классе все открытые члены базового класса. Если не использовать модификатор доступа, то класс `Son` ничего не будет знать о свойствах класса `Dad`.
Класс `Son` в данном случае называется производным классом, а класс `Dad` - базовым.

```cpp
class Dad {
    public:
        Dad(int age, float hp, std::string name) {
            // some work
        }
}
class Son : public Dad {
    public: 
        Son(int age1, float hp1, std::string name1, std::string date1) : Dad(age1, hp1, name1) {
            // some new work
        }
}
```
Когда нибудь может получиться так, что нужно будет запретить наследование. Для этого существует спецификатор `final`.
```cpp
class FinalFinalShit final {
    // some work 
}
```

### 5. Принцип полиморфизма
При рассмотрении полиморфизма необходимо помнить, что этот принцип неразрывно связан с другим принципом
    ООП – наследованием, которое помогает реализовать полиморфизм.
Возьмем для примера абстрактный класс «Автомобиль», который наследуют два конкретных класса – «Спортивный автомобиль» и «Грузовой автомобиль».
И спортивные, и грузовые автомобили будут обладать общими характеристиками и будут иметь возможность выполнять общие для всех автомобилей действия, которые указаны в абстрактном классе-родителе, но конкретная реализация этих действий может быть разной.
Например, общее для всех автомобилей действие «завестись» у спортивного автомобиля может быть реализовано путем нажатия кнопки, а у грузового - с помощью ключа. Один результат – разные решения. В этом и состоит полиморфизм.

> Более строго, **полиморфизм** - один из принципов ООП, позволяющий вызовом переопределённого метода через переменную класса-родителя получить поведение, которое будет соответствовать реальному классу-потомку, на который ссылается эта переменная.

### 6. Типы данных в С++. Пользовательские типы
Базовые типы данных:
- bool 
```cpp
bool isAlive {true};
bool isDead {false};
```
- целочисленные типы (`short`, `int`, `long` и тд)
- числа с плавающей точкой (`float`, `double`, `long double`)
- символьные типы (char и его клоны на разное количество памяти)

Пользовательские типы:
- классы и структуры
- объединения (аля кортежи из python, только хранят данные в одной области памяти)
```cpp
union MyUnion {
    int intValue;
    float floatValue;
}
```
- перечисления (enums)
```cpp
enum Colors {
    RED, BLUE, GREEN
} 
```
- шаблоны классов и функций 

### 7. Указатели в С++, адресная арифметика, ссылки

```cpp
// работа с указателями 
int value = 10;
int* ptr = &value; 
int x = *ptr;   // x = 10 
*ptr = 20       // value = 20

// адресная арифметика
int lst[3] = {30, 40, 50};
int* ptr1 = lst;
ptr++;          // *ptr -> 40
ptr--;          // *ptr -> 30
ptr = ptr + 2   // *ptr -> 50

// работа с ссылками
void increment(int& num) {
    num++;
}

void print(const int& name) { // константная ссылка, name не может быть изменен внутри функции
    // some work 
}

void main {
    int value = 10;
    increment(value);  // value = 11
}
```

### 8. Перечислимый тип enum

```cpp
enum Colors {
    RED,
    BLUE, 
    GREEN
};

enum class HttpStatus {
    OK = 200,
    NOT_FOUND = 404,
    INTERNAL_SERVER_ERROR = 500
};
```
Преимущества использования `enum`
- Улучшение читаемости кода: Именованные константы делают код более понятным
- Предотвращение ошибок: Использование enum помогает избежать ошибок, связанных с "магическими числами"
- Типобезопасность: `enum` class обеспечивает типобезопасность, предотвращая неявное преобразование к целочисленным типам

### 9. Пространство имен namespace
Пространство имен (namespace) в C++ используется для организации кода и предотвращения конфликтов имен. Оно позволяет группировать связанные сущности (классы, функции, переменные и т.д.) в логические блоки, что улучшает читаемость и поддержку кода.

1) Пространства имен помогают структурировать код, группируя связанные сущности.
```cpp
namespace Math {
    const double PI = 3.14159;
    double square(double x) {
        return x * x;
    }
}

void main() {
    double result = Math::square(5);                // Использование функции из пространства имен Math
    std::cout << "Result: " << result << std::endl; // Выведет 25
}
```
2) Пространства имен предотвращают конфликты имен, когда разные части кода используют одинаковые имена
```cpp
namespace ProjectA {
    void display() {
        std::cout << "Display from ProjectA" << std::endl;
    }
}

namespace ProjectB {
    void display() {
        std::cout << "Display from ProjectB" << std::endl;
    }
}

int main() {
    ProjectA::display(); // Выведет "Display from ProjectA"
    ProjectB::display(); // Выведет "Display from ProjectB"
}
```
3) Ключевое слово `using` позволяет упростить доступ к сущностям в пространстве имен
```cpp
namespace Math {
    const double PI = 3.14159;

    double square(double x) {
        return x * x;
    }
}

int main() {
    using namespace Math;
    double result = square(5); // Теперь можно использовать square без указания пространства имен
    std::cout << "Result: " << result << std::endl; // Выведет 25
    return 0;
}
```

### 10. Синтаксис класса в С++. Поля данных, методы
Прикола не понял, 
[см.1 вопрос](#1-основы-ооп-класс-объект)

### 11. Конструктор, деструктор
Общая информация все еще в [1 вопросе](#1-основы-ооп-класс-объект)

Конкретные примеры
```cpp
class Person {
private:
    std::string name;
    int age;

public:
    // Конструктор по умолчанию
    Person() : name("Unknown"), age(0) {}
    // Параметризованный конструктор
    Person(const std::string& name, int age) : name(name), age(age) {}
    // Конструктор копирования
    Person(const Person& other) : name(other.name), age(other.age) {}
    // Деструктор
    ~Person() {}
};

int main() {
    Person person1; // Вызов конструктора по умолчанию
    Person person2("Alice", 30); // Вызов параметризованного конструктора
    Person person3 = person2; // Вызов конструктора копирования
    return 0; // Объекты person1, person2 и person3 будут уничтожены, вызов деструктора
}
```

### 12. Специальные методы класса
Существует несколько специальных методов класса, к которым относятся конструкторы по умолчанию и копирования, а также деструкторы, описанные выше. Стоит отдельно сказать лишь про оператор присваивания копированием
```cpp
сlass MyClass {
public:
    MyClass& operator=(const MyClass& other) {
        if (this != &other) {
            data = other.data;
        }
        std::cout << "Copy assignment operator called" << std::endl;
        return *this;
    }
private:
    int data;
};

// используется как 
obj2 = obj1;  // где obj1 - уже объявленный объект класса MyClass
```

### 13. Уровни доступа в классе
Прикола не понял х2, все описано в [3 вопросе](#3-принцип-инкапсуляции-класса)

### 14. Функции-друзья, классы-друзья
Вкратце, функции и классы друзья при их объявлении в другом классе имеют доступ к защищенным и закрытым данным другого класса

```cpp
class MyClass;

class FriendClass {
public:
    void displayPrivateData(const MyClass& obj);
};

void displayPrivateData(const MyClass& obj) {
    std::cout << "Private data: " << obj.privateData << std::endl;
}

class MyClass {
private:
    int privateData;

public:
    MyClass(int value) : privateData(value) {}
    friend void displayPrivateData(const MyClass& obj);     // Объявление функции-друга
    friend class FriendClass;                               // Объявление класса-друга целиком
     // можно объявить дружественной только одну конкретную функцию класса
    friend void FriendClass::displayPrivateData(const MyClass& obj);
};

void main() {
    MyClass obj(10);
    displayPrivateData(obj); // Вызов функции-друга, отказа доступа не будет
    FriendClass friendObj;  // вызов клосса-друга
    friendObj.displayPrivateData(obj); // Вызов дружественной функции-члена
}
```

### 15. Наследование в С++
Основы даны в [4 вопросе](#4-принцип-наследования-класса), отдельно хочется сказать лишь про виды наследований: public, protected, private

1) Public наследование:
    - Публичные члены базового класса становятся публичными членами производного класса.
    - Защищенные члены базового класса становятся защищенными членами производного класса.
    - Приватные члены базового класса недоступны в производном классе.

2) Protected наследование:
    - Публичные и защищенные члены базового класса становятся защищенными членами производного класса.
    - Приватные члены базового класса недоступны в производном классе.

3) Private наследование:
    - Публичные и защищенные члены базового класса становятся приватными членами производного класса.
    - Приватные члены базового класса недоступны в производном классе.

### 16. Перегрузка методов, виртуальные методы
Виртуальная функция - это функция, объявленная в базовом классе и переопределенная в производных классах. Она обладает виртуальностью, то есть вызов функции осуществляется в зависимости от типа объекта, а не от типа указателя или ссылки, через которые он вызывается.

Виртуальные функции позволяют реализовать полиморфизм, то есть вызывать различные реализации функции в зависимости от типа объекта. Это позволяет использовать объекты различных классов с одинаковым интерфейсом в едином коде, не зная конкретный тип объекта.

```cpp
class Entity {
public:
    virtual void attack() { // виртуальная функция
        std::cout << "Attacking..." << std::endl;
    }
    // чистая виртуальная функция, те функция, котоорая должна быть определена в дочерних классах
    virtual void getType() = 0  
};

class Player : public Entity {
public:<
    void attack() override { // переопределение виртуальной функции
        std::cout << "Player is attacking..." << std::endl;
    }
};
```

### 17. Перегрузка операторов

>Оператор – это символ, который работает со значением или переменной. Например, =, +, -, <, >> - все это является операторами. 

Соответственно для работы с нашими произовльными классами, а именно применений методов к ним, используется перегрузка операторов. Пример перегрузки 
```cpp
Complex operator+(const Complex c1){
  // Перегрузка оператора сложения для комплесных чисел
  Complex temp;
  temp.real = real + c1.real;
  temp.imag = imag + c1.imag;
  return temp;
}
```

### 18. Обработка исключений
По сути заключается в кастомной обработке ошибок. Используется для корректного завершения программы. 
```cpp
int main() {
    try {
        std::string s = "Somebody ones told me";
        std::cout << s.at(69) << std::endl; // вызов исключения std::out_of_range
    }
    catch (const std::exception &e) {
        std::cerr << "Caught an out_of_range exception: " << e.what() << std::endl;
    }
    return 0;
}
```
Также можем создавать собственные ошибки и вызывать их
```cpp
double divide(double x, double y) {
    if (y == 0) {
        throw std::runtime_error("Division by zero");
    }
    return x / y;
}
```

### 19. Шаблонные функции
> Шаблон - это конструкция, которая создает обычный тип или функцию во время компиляции на основе аргументов, которые пользователь предоставляет для параметров шаблона.
```cpp
template<typename T1, typename T2>
T1 Sum(T1 a, T2 b) {
  return a + b;
}

Sum(3.4, 6)
Sum(3, 4)
```

### 20. Шаблонные классы
К унификации типов данных, тут можно добавить и значения, которые будем передавать
```cpp 
template <typename T1, typename T2>
class TwoNumbersWorker {
public:
  TwoNumbersWorker(T1 a, T2 b) {
    this->a = a;
    this->b = b 
  }

  T1 Sum() {
    return a + b;
  }   

private:
  T1 a;
  T2 b;
} 

TwoNumbersWorker<int, int> worker(3, 5); 
```

```cpp
template<typename T, size_t L>
class Array
{
    T arr[L];
public:
    Array() {}
};
MyArray<int, 10> arr;
```

### Лямбда-функции в С++
Общий синтаксис лямбда-функции выглядит следующим образом:
```cpp
[capture](parameters) -> return_type {
    // тело функции
}
```
- [capture]: Список захваченных переменных из окружающей области видимости.
- (parameters): Список параметров лямбда-функции.
- -> return_type: Возвращаемый тип функции (необязательно).
- { ... }: Тело функции.

Примеры лямбда функций 
```cpp
void main() {
    auto add = [](int a, int b) {
        return a + b;
    };
    int result = add(3, 4);
    std::cout << "Sum: " << result << std::endl; 

    int value = 10;
    auto printValue = [value]() {
        std::cout << "Value: " << value << std::endl;
    };
    printValue(); // Выведет 10

    auto increment = [&value]() {
        value++;
    };
    increment();
    std::cout << "Value: " << value << std::endl; // Выведет 11
}
```

### 22. Коллекции данных, контейнеры
В C++ стандартная библиотека (STL) предоставляет множество контейнеров для хранения и управления коллекциями данных. Эти контейнеры делятся на несколько категорий: последовательные контейнеры, ассоциативные контейнеры и контейнеры-адаптеры. Каждый тип контейнера имеет свои особенности и области применения. 

1) Последовательные контейнеры хранят элементы в линейном порядке. 
Основные последовательные контейнеры включают:

    1. `std::vector`:
        > Динамический массив, который может изменять свой размер. \
        Предоставляет быстрый доступ к элементам по индексу.
    2. `std::list`:
        > Двусвязный список, который позволяет эффективно вставлять и удалять элементы.
    3. `std::array`:
        > Статический массив фиксированного размера

2) Ассоциативные контейнеры хранят элементы в виде пар "ключ-значение" и позволяют эффективно искать элементы по ключу

    1. std::map - аналог словаря с уникальными ключами
    2. std::unordered_map - аналог 1 пункта, только неупорядоченные пары
    3. std::set - аналог множества с уникальными элементами 
    4. std::unordered_set - и так все понятно
    5. multimap - аналог 1 с возможностью повторений ключей
    6. multiset - аналог 3 с возможностью повторений значений 

### 23. Итераторы
>Итераторы в C++ предоставляют способ последовательного доступа к элементам контейнеров. Они позволяют перебирать элементы контейнера, не завися от его внутренней структуры. 
```cpp
#include <iostream>
#include <vector>

void main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};
    // Использование итератора для перебора элементов
    for (std::vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {
        std::cout << *it << " ";
    }
}
```

### 24. std::vector
std::vector является одним из наиболее часто используемых контейнеров в стандартной библиотеке C++ (STL) благодаря своей гибкости и удобству. 

*Плюсы использования std::vector*

- Динамический размер:
        std::vector автоматически управляет своим размером, увеличиваясь по мере необходимости. Это упрощает работу с динамическими массивами данных.

- Быстрый доступ по индексу:
        std::vector предоставляет константное время доступа к элементам по индексу (O(1)), что делает его очень эффективным для операций чтения и записи.

- Простота использования:
        std::vector имеет интуитивно понятный интерфейс, который похож на работу с обычными массивами, но с дополнительными функциями для управления размером и емкостью.

- Совместимость с алгоритмами STL:
        std::vector хорошо интегрируется с алгоритмами стандартной библиотеки C++, такими как std::sort, std::find, std::for_each и многими другими.

- Эффективное добавление элементов:
        Добавление элементов в конец вектора (push_back) обычно выполняется за амортизированное константное время (O(1)).

- Управление памятью:
        std::vector автоматически управляет памятью, освобождая её при уничтожении объекта, что снижает вероятность утечек памяти.

*Минусы использования std::vector*

- Перераспределение памяти:
        Когда вектор превышает свою текущую емкость, он выделяет новую память и копирует все элементы в новое место. Это может быть дорогостоящей операцией, особенно для больших векторов.

- Фиксированная емкость:
        Хотя вектор может изменять свой размер, его емкость (выделенная память) может быть больше, чем фактический размер, что может привести к избыточному использованию памяти.

- Дорогостоящие вставки и удаления в середине:
        Вставка или удаление элементов в середине вектора требует перемещения всех последующих элементов, что делает эти операции дорогими (O(n)).

- Ограниченная поддержка многопоточности:
        std::vector не является потокобезопасным контейнером. Одновременное чтение и запись из нескольких потоков может привести к неопределенному поведению, если не использовать механизмы синхронизации.

- Неэффективное использование памяти для маленьких объектов:
        Для хранения маленьких объектов или простых типов данных std::vector может быть менее эффективным по сравнению с другими контейнерами, такими как std::deque или std::list.


### 25. std::list
std::list - это контейнер, предоставляемый библиотекой стандартных шаблонов C++ (STL), который реализует двусвязный список. Каждый элемент списка содержит указатель на предыдущий и следующий элементы, кроме первого и последнего, которые не имеют предыдущего и следующего элементов соответственно. Двусвязный список может быть эффективным выбором в некоторых случаях, например, когда нужно быстро вставлять или удалять элементы в середине контейнера, поскольку эти операции не требуют перемещения других элементов в контейнере.

Преимущества использования std::list:

- Вставка и удаление элементов в середине списка происходит быстро и не требует перестроения всего списка.
- Нет необходимости копировать элементы при вставке или удалении элементов.
- Возможность добавления и удаления элементов в начале и конце списка.

Недостатки использования std::list:

- Доступ к элементам списка происходит не по индексу, а только через итераторы, что может быть неудобно в некоторых ситуациях.
- Доступ к элементам списка происходит медленнее, чем в других контейнерах, таких как std::vector, из-за необходимости перехода по указателям на предыдущий и следующий элементы.
- Большой расход памяти из-за необходимости хранения указателей на предыдущий и следующий элементы.

### 26. std::map

 ```cpp
 std::map<std::string, int> map2 = {{"one", 1}, {"two", 2}, {"three", 3}};
 ```

 Плюсы

- Упорядоченность:
        Элементы в std::map хранятся в отсортированном порядке по ключам, что позволяет эффективно выполнять операции поиска, вставки и удаления.

- Уникальные ключи:
        Ключи в std::map уникальны, что предотвращает дублирование данных.

- Эффективные операции:
        Операции вставки, удаления и поиска выполняются за логарифмическое время (O(log n)).

- Простота использования:
        std::map предоставляет интуитивно понятный интерфейс для работы с парами "ключ-значение".

Минусы

- Дополнительные накладные расходы:
        std::map использует красно-черное дерево для хранения элементов, что может привести к дополнительным накладным расходам по памяти и времени по сравнению с хеш-таблицами (например, std::unordered_map).

- Медленные операции поиска по сравнению с хеш-таблицами:
        Операции поиска в std::map выполняются за O(log n), тогда как в хеш-таблицах (например, std::unordered_map) они выполняются за амортизированное константное время (O(1)).

- Неэффективное использование памяти:
        Красно-черное дерево может использовать больше памяти по сравнению с другими структурами данных, такими как хеш-таблицы или массивы.
